\thispagestyle{empty}
\changepage{}{}{}{-0.5cm}{}{2cm}{}{}{}
![The Little Redis Book, By Karl Seguin](title.png)\

\clearpage
\changepage{}{}{}{0.5cm}{}{-2cm}{}{}{}

## この本について

### ライセンス

The Little Redis Book は the Attribution-NonCommercial 3.0 Unported license の元でライセンスされます｡この本にお金を払う必要はなく､またそうすべきではありません｡

複製､配布､修正､提示は自由に行えますが､この本の著者が私 Karl Seguin であることを常に明らかにしてくれるようお願いします｡また､この本を商用利用してはいけません｡

**ライセンス**の*全文*は以下で読むことが出来ます｡

<http://creativecommons.org/licenses/by-nc/3.0/legalcode>

### 著者について

Karl Seguin は様々な分野と技術に長けた開発者です｡オープンソースプロジェクトの活発な貢献者であり､技術記事の著者であり､時に講演者でもあります｡彼はRedisの他にもいくつかのツールについて様々な記事を書いています｡ Redisは彼のカジュアルゲーム開発者向けの3つのサービス: [mogade.com](http://mogade.com/)でランキングや統計にその力を発揮しています｡

Karl は [The Little MongoDB Book](http://openmymind.net/2011/3/28/The-Little-MongoDB-Book/) という本も書きました｡この本はMongoDBについて書かれており､フリーで人気があります｡

彼のブログは <http://openmymind.net> で､ Twitterアカウントは [@karlseguin](http://twitter.com/karlseguin)
 です

### 謝辞

目と心と情熱で私を助けてくれた [Perry Neal](https://twitter.com/perryneal) に特別な感謝を捧げます｡貴方の助けはかけがえなのないものでした､ありがとう｡

### 最新版

この本の最新版は以下から入手できます｡
<http://github.com/karlseguin/the-little-redis-book>

\clearpage

## はじめに

過去何年かに渡って､データ永続化と問い合わせの技術やテクニックは信じがたいペースで成長してきました｡ RDBではどうにもならないところに来ているというのは確実なところですが､一方でデータを取り巻くエコシステムはその限界を超えていくだろうとも言えるでしょう｡(訳者注：訳文意味不明瞭､原文を以下に残す)
While it's safe to say that relational databases aren't going anywhere, we can also say that the ecosystem around data is never going to be the same.

あらゆる新しいツールやソリューションの中で､Redisは私にとってもっともエキサイティングです｡その理由の第一は､信じがたいほどに簡単に学べるということです｡Redisに慣れるのにかかる時間といえば数時間といったところでしょう｡第二に､Redisは特定の問題を解決すると同時にかなり一般的であるということです｡つまりどういうことかというと､Redisはあらゆるデータに対して何でもかんでもやろうとしません｡Redisを知るにつれ､何がRedisに適していて､何がそうでないか､徐々にはっきりしていくでしょう｡そして全てが明らかになった時､開発者にとってそれは素晴らしい体験です｡

Redisだけを使って全てのシステムを作ることは出来ますが､ほとんどの人はRedisを伝統的なRDBやドキュメント指向データベースといった一般的なデータソリューションの補助と見るだろうと思います｡ Redisは特定の機能を実現するための手段です｡その意味で､インデックスエンジンに似ています｡アプリケーションをLuceneだけで作ったりはしないでしょう｡しかし強力な検索が必要なら､ユーザにとっても開発者にとってもより良い選択です｡もちろんRedisとインデックスエンジンで似ているところといえばそれだけですが｡

この本の目的はRedisを使いこなすための基礎を学ぶことです｡Redisの5つのデータ構造に焦点を当てて､様々なデータモデリングアプローチを検討します｡また同時にいくつかの主な管理とデバッグの方法にも触れます｡

## さあ､はじめよう

我々は皆異なった学び方をします｡ある人は手を動かすことを好み､またある人はビデオを見ることを好み､さらにある人は読むことを好みます｡ Redisを理解するのには実際に触ってみるのが一番です｡Redisのインストールは簡単で､必要なことは全部できる対話環境が使えます｡ここで少し時間をとって自分のマシンでRedisを動かしてみましょう｡

### Windows環境

Redisは公式にはWindowsをサポートしていません｡しかしいくつか方法があります｡これらのやり方を実運用環境で使いたいとは思わないでしょうが､個人的には開発環境で制限に出くわしたことはありません｡

まず､ここ <https://github.com/dmajkic/redis/downloads> にいって､最新のバージョンをダウンロードしてください
(リストの一番上にあるのがそうです)

zipファイルを解凍し､32bitか64bitのうち適切な方のフォルダを開きます｡

### *nix環境とMacOSX環境

*nixとMacユーザにとってはソースからビルドするのが最善の方法でしょう｡ビルド方法はその最新のバージョン番号と共に <http://redis.io/download> で手に入ります｡この稿を書いている時点での最新版は2.4.6です｡このバージョンをインストールするには以下のようにします｡

	wget http://redis.googlecode.com/files/redis-2.4.6.tar.gz
	tar xzf redis-2.4.6.tar.gz
	cd redis-2.4.6
	make

(別の方法として､Redisはパッケージマネージャ経由でインストールすることも出来ます｡例えばMacOSユーザは `brew install redis` と打つことでインストールできます)

ソースからビルドした場合は､コンパイルされたバイナリは `src` ディレクトリに置かれます｡ `src` ディレクトリに移動するには `cd src` を実行します｡

### Redisを起動し､接続する

全てが上手くいったら､redisバイナリが利用可能になっているはずです｡Redisは便利な実行ファイルを持っています｡それらのうち､RedisサーバとRedisコマンドラインインターフェイスに焦点を当てます｡まずサーバを実行しましょう｡Windowsでは `redis-server` をダブルクリック､ *nixかMacOSXでは `./redis-server` を実行です｡

スタートアップメッセージを読むと､ `redis.conf` ファイルが見つからないという警告が出ているのに気がつくと思います｡Redisはデフォルト設定で起動しています｡これからの演習にはデフォルト設定で十分です｡

次にRedisコンソールを立ち上げます｡Windowsでは `redis-cli` をダブルクリック､*nix/MacOSXでは `./redis-cli`を実行です｡これでローカルで実行されているサーバにポート6379でつながります｡

コマンドラインに `info` と入力することでRedisがきちんと動いているかどうか確かめることが出来ます｡正常に動いていればサーバの稼働状況を示す大量のキーと値のペを目にすることでしょう｡

ここまででなにか問題があれば [公式Redisサポートグループ](https://groups.google.com/forum/#!forum/redis-db)　で助けを求めることをお勧めします｡

## Redis Drivers

これから見ていくように､RedisのAPIは関数の集合として表現されます｡ APIは非常に単純で順序だっており､これはつまり､コマンドラインツールを使おうが､好みの言語のドライバを使おうが､やることはほとんど同じだということです｡したがって以降の内容を好みのプログラミング言語で実行しても何ら問題はないでしょう｡もし必要があれば [client page](http://redis.io/clients) へ行ってドライバをダウンロードしてください｡

\clearpage

## 第一章 - 基本

なにがRedisを際立たせているのでしょうか？Redisはどんなタイプの問題を解決するのでしょうか？Redisを使う際に開発者が気をつけるべきことは何でしょうか？これらの質問に答える前に､まずRedisとはなにかを理解しなければなりません｡

Redisは良くインメモリ パーシスタント キーバリューストアと表現されます｡私はこれはあまり正確な表現だとは思いません｡Redisは全てのデータをメモリ上に持ち(これについては後ほど詳しく触れます)､そのデータを永続化のためにディスクに書きだします｡しかし､Redisは単なるキーバリューストア以上の存在です｡この誤解から離れることは重要です｡さもなければRedisの役割や解決できる問題はごく少ないものになってしまうでしょう｡

実際にはRedisは5つの異なったデータ構造を提供しており､それらのうち一つだけが､典型的なキーバリューストア構造です｡5つのデータ構造と､それらがどのように動き､どんなメソッドを提供し､データモデリングにどう使えるかを理解することがRedisを理解する鍵です｡しかしまず初めにデータ構造について思いを巡らせてみましょう｡

データ構造の考え方をリレーショナルデータベースにあてはめると､データベースは一つのデータ構造だけを提供します｡それはテーブルです｡テーブルは行と列からなり､柔軟です｡モデルを作ったり､格納したり､データを操作したりとテーブルについてできないことはほとんどありません｡しかし欠点もあります｡それは､何もかもが単純ではなく､速くもない､ということです｡本来はそうあるべきなのに｡もし一つのデータ構造で何でもかんでもやろうとするのではなく､より特化した構造が使えたとしたらどうでしょう？確かにやれないこともでてくるでしょうが､単純さと速さを得ることができるのではないでしょうか？

ある問題に適したデータ構造を使うというのは我々がプログラムを書くときにやっていることではないでしょうか？ハッシュテーブルやスカラー変数をあらゆるデータに使ったりはしないでしょう｡Redisのやり方というのはそういう事です｡スカラーやリストやハッシュや集合を扱うなら､それをそのまま保存すればいいのではないでしょうか？どうして値の存在を確認するために `exists(key)` 以上の複雑なことをしなければならないのでしょう？あるいは O(1)(項目数に関わらず一定の時間で検索できること)以上の時間のかかることをしなければいけないのでしょう？

## ブロックを積み上げる

### データベース

Redisは既にあなたにとって馴染みのあるデータベースの概念と同じ基本的な考え方を持っています｡データベースはデータの集合を保持します｡データベースの典型的な利用例はアプリケーションのデータをひとまとめにして他のアプリケーションから分離することです｡

Redisにおいては､データベースは単なる数字で認識されます｡デフォルトのデータベースは `0` です｡別のデータベースに変更したいなら､`select`コマンドで変更できます｡コマンドラインインターフェイスで `select 1` と入力してみましょう｡Redisが `OK` メッセージを返し､プロンプトが `redis 127.0.0.1:6379[1]` のように変わるはずです｡デフォルトのデータベースに戻りたければ､コマンドラインインターフェイスで `select 0` と入力してください｡

### コマンドとキーと値

Redisは単なるキーバリューストア以上の存在ですが､本質的にはRedisの5つのデータ構造は全てキーと値を持ちます｡より深く学ぶ前に､まずキーと値について理解することが必要です｡

キーはデータを識別する方法です｡キーについては後ほど十分に取り扱いますので､今のところはキーが `users:leto` のような見た目をしていると知っていれば十分です｡このようなキーが `leto` という名前のユーザについての情報を格納しているということは容易に推測できるでしょう｡ Redisにとってコロンは何ら特別な意味を持ちません｡しかしキーの構成にセパレータを用いることは一般的です｡

値はキーに関連付けられた実際のデータのことです｡値はどんな形でも構いません｡文字列を入れることもあれば､整数を入れることもあり､また時にはシリアライズされたオブジェクトのこともあるでしょう(JSONとかXMLとか)｡大抵の場合､Redisは値を単なるバイト列として取り扱い､中身には頓着しません｡しかし､ドライバによってはシリアライゼーションの取り扱いに差異があることには注意してください｡この本では文字列と整数とJSONだけを取り扱うことにします｡

すこし手を動かしましょう､次のコマンドを入力してください：

	set users:leto "{name: leto, planet: dune, likes: [spice]}"

これがRedisのコマンドの基本です｡まずコマンドを指定します､次に上の例では`set`です｡次に引数がきます｡ `set`コマンドは2つの引数を取ります｡これから設定しようとするキーと､キーに設定する値です｡全てではありませんがほとんどの場合コマンドはキーを引数に取り､その場合たいていキーが最初にきます｡今設定した値を取り出すにはどうすればいいかわかりますか？
お分かりだと思いますが､わからなくても心配ありません｡

	get users:leto

他の組み合わせも試してみてください｡キーと値は基本となる概念です｡そして`get`コマンドと`set`コマンドはキーと値を扱う一番単純な方法です｡もっとユーザを作り､違ったキーを試し､違った値を入れてみてください｡

### クエリ

次に2つのことを明らかにしましょう｡ことRedisにおいては､キーが全てであり､値には意味がありません｡別の言い方をすれば､Redisでは値についてクエリを投げることはできません｡上の例で言えば､惑星`dune`に住むユーザを見つけることはできないのです｡

多くの人にとってこれは困ったことに思えるでしょう｡我々はデータクエリが非常に柔軟で､非常に強力な世界に住んでいます｡そのためRedisのやり方は原始的で実際的ではないように思えるでしょう｡しかしなにも心配することはありません｡思い出してください､Redisは万能のソリューションではありません｡クエリの制限によってRedisには適さない問題というのもあるのです｡また､場合によってはデータをモデリングする別の方法を見つけることもあるでしょう｡

これからもっと具体的な例を見ていくことにしますが､この基本的事実を理解しておくことは重要です｡これによって､なぜ値は何でもありなのかが理解できます｡なぜならRedisは決して値を読んだり理解したりする必要がないからです｡また､この新しい考え方でデータをモデリングする際の助けにもなります｡

### メモリと永続化

先ほどRedisはインメモリ パーシスタント ストア だといいました｡永続化の点について言えば､デフォルトではRedisは変更されたキーの数に基づいてデータベースのスナップショットをディスクに保存します｡ X個のキーが変更されたら､Y秒ごとにデータベースを保存するという設定ができます｡デフォルトでは1000以上のキーが変更された場合は60秒ごとに､9あるいはそれ以下のキーが変更された場合には15分おきにデータベースを保存します｡

別の方法として､あるいはスナップショットと併せて､Redisは追加モードで動かすことができます｡キーが追加／変更される度にディスク上のappend-onlyファイルが更新されます｡ハードウェアなりソフトウェアなりの障害はつきものです｡パフォーマンスを得るために60秒間のデータを失ってもいい場合というのはあるでしょう｡しかしそのようなデータの喪失が許されないこともあります｡ Redisではこの2つを選ぶことができます｡第5章では3つ目の選択として永続化作業をスレーブに任せる方法を紹介します｡

メモリに関して言えば､Redisは全てのデータをメモリ上に保持します｡これはRedisを動かすのにはお金がかかるということを意味します｡RAMはいまだにサーバの最も高価なパーツです｡

私はデータが取るスペースどれほど少ないものかを理解していない開発者がいると感じます｡シェイクスピアの全作品はおおよそ5.5MBです｡スケーリングについては､他のソリューションはIOバウンドかCPUバウンドしがちです｡ RAMかIOの限界によってたくさんのマシンへとスケールアウト必要があるかどうかは､取り扱うデータタイプに強く依存します｡もし巨大なマルチメディアファイルをRedisに保存するのでなければ､メモリについてはおそらく問題にはなりません｡アプリケーションにとってはメモリバウンドよりもIOバウンドのほうが問題になりがちでしょう｡

Redisはバーチャルメモリをサポートしています｡しかし､この機能はRedisの開発者たちに失敗だとみなされています｡いずれ廃止されることになるでしょう｡

(付け足しとして､5.5MBのシェイクスピア全集は約2MBに圧縮することができます｡Redisは自動で圧縮を行いませんが､値はバイト列なので､あなた自身がCPU時間を使って圧縮／解凍を行い､RAMを節約できない理由はなにもありません｡)

### ここまでのまとめ

ここまで多くの概念について触れてきました｡具体的なRedisの使い方に踏み込む前に一度これらをまとめておきたいと思います｡とりわけクエリの制限､データ構造､そしてRedis流メモリへのデータ保存の方法についてです｡

これら3つを組み合わせると素晴らしい物を得られます｡それは速さです｡「そりゃ速いだろうさ､全部メモリ上にあるんだから」と思う人が居るでしょうが､それは速さの一部分にすぎません｡ Redisが他のデータベースと比較して真に輝くのはその特別なデータ構造によってです｡

一体どれほど速いのでしょう？それは多くの要因に依ります｡使うコマンド､データタイプ､そういったことです｡しかしRedisの速度は「一秒に」何万とか､何十万とかの単位で測定されます｡これは `redis-benchmark` コマンド(redis-serverやredis-cliと同じフォルダにあります)を実行することでユーザ自身が確認できます｡

私はかつてリレーショナルデータベースをRedisに変更したことがあります｡ RDBでのロードテストには5分以上かかりましたが､Redisでは150ミリ秒で終わりました｡

このRedisの性質を理解することは重要です｡なぜならそれがRedisの使い方に大きな影響を与えるからです｡ SQLを使い慣れた開発者はデータベースへの問い合わせをできるだけ少なくしようとします｡ Redisを含むあらゆるシステムにとってそれはいいアドバイスです｡しかしながらよりシンプルなデータ構造を扱う前提に立つと､目的を達するために複数回Redisにアクセスする必要が生じることがあります｡このようなデータアクセスパターンは最初は不自然に感じられるかもしれません｡しかし現実には実際に得られるパフォーマンスに比べるとごく僅かなコストで済むことが多いのです｡

### この章のまとめ

ほとんどRedisそのものには触っていませんが､たくさんの話題について触れました｡何かわからないこと､例えばクエリとか､があっても心配しないでください｡次の章で実際に手を動かすことで､疑問が氷解することでしょう｡

この章のポイント:

* キーはデータ(値)を識別する文字列

* 値は任意のバイト列で､Redisはその中身に一切関知しない

* Redisは5つのデータ構造を提供する

* 以上のことから､Redisは高速で容易に扱えるが､全ての課題に最適なわけではない｡
\clearpage

## 第二章 - データ構造

Redisの5つのデータ構造について見ていきましょう｡それぞれのデータ構造について解説し､どんなメソッドが利用可能で､どんな機能やデータが適するのか見てきます｡

これまでに見てきたRedisの要素はコマンドとキーと値だけでした｡データ構造については詳しく触れていません｡ `set`コマンドを使うときに､Redisはどうやってどのデータ構造を使うか判別するのでしょうか？実は全てのコマンドはデータ構造と結びついているのです｡たとえば`set`コマンドを使う時､格納される値は文字列です｡ `hset`コマンドを使うとハッシュとして格納します｡ Redisのコマンド群に少し馴染めば実に扱いやすくできています｡

**[Redisのウェブサイト](http://redis.io/commands) には大変良く出来たリファレンスがあります｡同じ事を繰り返す必要はないので､データ構造の目的を理解するのに必要な最も重要なコマンドだけを取り上げます｡**

実際に物事に取り組んで楽しむことほど大事なことはありません｡ `flushdb`コマンドでいつでもデータベースを全消去できるので､ためらわずに思う存分試してみてください｡

### 文字列

文字列はRedisで一番基本的なデータ構造です｡一般にキーと値のペアというと文字列のことを思い浮かべるでしょう｡しかし名前に惑わされないでください､値は何だっていいのです｡私はそれらをスカラー値と呼ぶのが好きですが､たぶんこれは私だけでしょう｡

文字列の使い方については既に見ました｡オブジェクトのインスタンスをキーによって保存します｡次のような使い方を頻繁にすることでしょう：

	set users:leto "{name: leto, planet: dune, likes: [spice]}"

加えて､いくつかありふれた操作も行えます｡たとえば `strlen <key>` とすると､キーが示す値の長さを得られます｡`getrange <key> <start> <end>` は値の指定した範囲を返します｡ `append <key>` は既にあるキーに値を追加するか､キーが存在しなければ新しく作成して追加します｡実際にやってみて下さい｡次のような結果になります：

	> strlen users:leto
	(integer) 42

	> getrange users:leto 27 40
	"likes: [spice]"

	> append users:leto " OVER 9000!!"
	(integer) 54

さて､あなたはこれを見て「なるほどわかった､しかしこんなのは意味がない」と考えているのではないでしょうか｡ JSONから範囲指定で値を取り出したり､値を追加したりすることには意味がありません｡ここでは文字列に限ったコマンドを実行する練習をしているだけです｡とうぜん文字列を扱う場合にしか意味がありません｡

先ほどRedisは値について関知しないといいました｡大抵の場合はそれは本当のことですが､幾つかもの文字列コマンドは値や構造に特化しています｡漠然とした例ですが､`append`とか`getrange`とかは効率のいいシリアライゼーションをするのに便利です｡より具体的な例としては`incr` `incrby` `decr` `decrby` コマンドがあります｡これらは文字列の値を増やしたり減らしたりします｡

	> incr stats:page:about
	(integer) 1
	> incr stats:page:about
	(integer) 2

	> incrby ratings:video:12333 5
	(integer) 5
	> incrby ratings:video:12333 3
	(integer) 8

ご想像のとおり､Redisの文字列は分析に大変役に立ちます｡試しに整数値ではない `users:leto` をインクリメントしようとしてみてください､エラーになるはずです｡

より進んだ例として `setbit` `getbit` コマンドがあります｡ [素晴らしい解説](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/) があります｡Spoolがこれらのコマンドを使ってどれほど効率的に一日のユニークビジター数を計算しているかの例です｡ 1億2800万ユーザを一台のラップトップで､50ミリ秒と16MBのメモリで処理しています｡

ビットマップの仕組みを理解することは重要ではありません｡同様にSpoolがどんなふうに使っているかというのも重要ではありません｡しかし Redisの文字列が見た目よりずっと強力だということは理解する必要があります｡しかし最も一般的な使われれ方は上に上げたようなオブジェクトを格納するとか､カウンターを作るとか､そういったことです｡またキーから値を得るのは大変速いので､文字列はよくキャッシュに使われます｡ 

### ハッシュ

なぜRedisが単なるキーバリューストアではないのか､その好例がハッシュです｡多くの点でハッシュは文字列と似通っています｡重要な違いはキーと値の間に追加要素があることです｡それはフィールドです｡したがって､ハッシュにおける `set` `get` は次のようになります：

	hset users:goku powerlevel 9000
	hget users:goku powerlevel

複数のフィールドを一度に設定したり､取得したりすることもできます｡全てのフィールドを表示したり､特定のフィールドを削除するには次のようにします：

	hmset users:goku race saiyan age 737
	hmget users:goku race powerlevel
	hgetall users:goku
	hkeys users:goku
	hdel users:goku age

見てわかるように､ハッシュは単なる文字列より扱いやすくなっています｡ユーザ情報をシリアライズされた文字列として保存するより､ハッシュで保存したほうが理解が容易です｡利点は値全部を読み書きするのではなく､値の特定の部分を取り出したり更新したり削除したりできることです｡

具体的なモデル､例えばユーザ情報とかを使ってハッシュを見ることが理解の鍵です｡そしてパフォーマンスの観点から､より細かなコントロールが有益です｡しかし次の章ではデータ構造化やクエリを行うのにハッシュをどのように利用できるのか見て行きます｡個人的にはハッシュが最もその効果を発揮する場面です｡


### リスト

リストはキーに対して値の配列を格納します｡リストに対して値を追加し､最初や最後の値を取得し､インデックスを使ってリスト内の値を操作できます｡リストは内部に順序を保持しており､効率の良いインデックスベースの操作が可能です｡ `newusers`リストを使って新しくサイトに登録したユーザを追跡できます：

	lpush newusers goku
	ltrim newusers 0 50

まず新しいユーザをリストの先頭に追加します｡次に最後の50ユーザだけを残して他を削除しています｡これが一般的なパターンです｡ `ltrim`はO(N)操作です｡Nは削除する要素の数です｡この例の場合､一回の追加の後にトリムします｡したがって常にO(1)の時間がかかることになります｡


次はあるキーの値を元に別のキーの値を参照するという初めての例です｡もし最新10ユーザの詳細が知りたければ､次の操作の組み合わせで可能です：

	keys = redis.lrange('newusers', 0, 10)
	redis.mget(*keys.map {|u| "users:#{u}"})

このコードはRubyの例です｡以前述べた複数回の問い合わせを行っています｡

もちろんリストは他のキーへの参照を保存するのに便利なだけではありません｡ログを保存したり､ユーザの行動履歴を保存したりするのにも使えます｡ゲームを作っているならユーザアクションのキューに使えるでしょう｡

### 集合

集合は一意な値を格納し､unionのような集合を扱う操作を提供します｡集合には順序がありませんが､値に基づいた効率的な操作が可能です｡友人リストが典型的な利用例でしょう：

	sadd friends:leto ghanima paul chani jessica
	sadd friends:duncan paul jessica alia

どれほどの友人がいようとも､O(1)の時間でユーザXがユーザYの友人であるかどうかを判断できます｡

	sismember friends:leto jessica
	sismember friends:leto vladimir

さらに2人以上の人が共通の友人を持っているかもわかります:

	sinter friends:leto friends:duncan

さらに結果を新しいキーとして保存することもできます:

	sinterstore friends:leto_duncan friends:leto friends:duncan

値が複数存在するのでなければ､集合はタグ付けをしたり追跡をしたり､あるいは交差や結合といった集合操作をおこなうのに最適の方法です｡

### ソート済み集合

最後の､そして最も強力なデータ構造はソート済み集合です｡ハッシュがフィールドつき文字列だとしたら､ソート済み集合はスコア付きの集合です｡スコアによってソートしたり順位付けをしたりできます｡友人の順位リストを得たければ次のようにします:

	zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir

`duncan`に90以上のランクの友dunが何人居るか知りたいですか？

	zcount friends:duncan 90 100

`chani`のランクを知りたいとしたら？

	zrevrank friends:duncan chani

`zrank`の代わりに`zrevrank`を使います｡なぜならRedisのデフォルトソートは低い方から高いほうへ並べ替えるからです｡この例では高い方から順に並べ変えています｡ソート済み集合の最も典型的な利用例はスコアボードでしょう｡しかし実際は数値で並べ替えられるもの､スコアで操作できるものはソート済み集合にぴったりでしょう｡

### この章のまとめ

以上がRedisの提供する5つのデータ構造の概要です｡ Redisのいいところはたくさんありますが､その内の1つは最初に思ったよりもはるかにたくさんのことができるということです｡文字列とソート済み集合を使って誰も思いつかなかったようなことができるでしょう｡しかし､一般的な利用例を理解しさえすれば､Redisがあらゆる問題に使えることに気がつくでしょう｡ Redisが5つのデータ構造とそれらを扱う大量の方法を提供しているからといって､それらを全て使わなければならないとは考えないでください｡
少ないコマンドで必要な機能を作るのは珍しいことではありません｡

\clearpage

## 第三章 - データ構造を活用する

これまでの章で､5つのデータ構造とそれらが解決しうる問題の例について解説しました｡次はより複雑で実際に即した話題やデザインパターンを見ていきましょう｡

### Big O Notation (ビッグオー記法)

この本の全体を通してビッグオー記法を用いています｡ビッグオー記法は O(n) や O(1)のような記述をし､与えられた要素数に対してどのような振る舞いをするかを表します｡Redisでは要素数に対するコマンド実行速度を表すのに使われます｡

Redisのドキュメントには各コマンドの実行時間がビッグオー記法で書かれています｡これを見ることで何が速度に影響するかを知ることができます｡幾つか例を見てみましょう｡

最も速いのは O(1) で､常に一定の速度で応答が返ってきます｡扱う要素数が5であろうが5百万であろうが､同じ速度が得られます｡たとえば値が集合に属しているかを判定する`sismember`コマンドは O(1) です｡`sismember`はその速さ故に強力なコマンドです｡Redisの多くのコマンドは O(1) です｡

対数コマンド O(log(N)) はO(1)の次に速い可能性があります｡なぜなら走査する対象が徐々に小さくなっていくからです｡このタイプの分割して統治せよアプローチを使うことで大量の要素は幾つの繰り返しに分解されます｡`zadd`コマンドはO(log(N))です｡Nは集合内の要素数を表します｡

次は線形コマンド O(N) です｡RDBでテーブル内の索引なしの列を走査するのがこのO(N)に当たります｡`ltrim`コマンドはO(N)です｡しかし`ltrim`の場合､Nはリスト内にある要素数を意味しません｡Nが意味するのは取り除かれる要素数です｡100万個のリストから1つの要素を取り除くのは､1000個のリストから10個の要素を取り除くのより早くなります｡(しかしながらほとんどわからないくらいの違いだとは思いますが)

スコア付き集合のスコアの範囲に基づいて要素を削除する `zremrangebyscore` コマンドは複雑で､O(log(N)+M)のようになります｡2つの要素に影響を受けるということです｡Redisのドキュメントを読むとNは集合内の要素の数であり､Mは削除される要素の数だとわかります｡言い換えれば､パフォーマンスの観点からはリスト(訳者注：集合の誤りか？)内の全要素数よりも､削除される要素の数のほうがより重要な意味を持つということでしょう｡ 

次の章で大きく取り上げる`sort`コマンドはさらに複雑で O(N+M*log(M)) となります｡速度の特性からRedisで最も複雑なコマンドの1つだと言えるでしょう｡

複雑なものはまだあります｡残りの2つは O(N^2) と O(C^N)です｡Nが大きくなればなるほど小さなNに比較してどんどんパフォーマンスが悪くなります｡Redisにはこのタイプのコマンドはありません｡

ビッグオー記法のワーストケースについて指摘しておくことは意味があります｡何かがO(N)であるという時､それは一番最初に見つかるかもしれないし､最後に見つかるかもしれないということです｡


### 擬似的な複数キー問い合わせ

1つの値の複数のキーに対して問い合わせをしたいというのはよくあることです｡たとえばログインする時メールアドレスからユーザを検索し､ログイン後はIDで検索したい､というような場合です｡まずいやり方としてはユーザオブジェクトを2つの文字列に複製するというのがあります:

	set users:leto@dune.gov "{id: 9001, email: 'leto@dune.gov', ...}"
	set users:9001 "{id: 9001, email: 'leto@dune.gov', ...}"

これはよくありません｡なぜならユーザデータの整合性管理はまるで悪夢であり､二倍のメモリを消費するからです｡

1つのキーから別のキーへとリンクを晴れれば良いのですが､それはできません｡将来に渡ってできるようになることもないでしょう｡Redisの開発においてはコードとAPIを完結かつシンプルに保つことが重要視されています｡キーリンクの実装にはあまり意味がありません､Redisはハッシュという解を既に用意しているからです｡

ハッシュを使うと重複を避けることができます:

	set users:9001 "{id: 9001, email: leto@dune.gov, ...}"
	hset users:lookup:email leto@dune.gov 9001

ここでやっているのはフィールドを擬似的な二次インデックスにして､ユーザオブジェクトへの参照を持たせていることです｡IDからユーザを検索するにはいつもどおり`get`を使います:

	get users:9001

メールアドレスからユーザを得るには､`hget`のあとに`get`を使います(以下はRubyの例です) :

	id = redis.hget('users:lookup:email', 'leto@dune.gov')
	user = redis.get("users:#{id}")

こういう処理を頻繁にすることになるでしょう｡私にとってこれがハッシュの威力を最も感じる場面です｡しかし実際に使ってみるまではよくわからないのです｡

### 参照とインデックス

1つの値から別の値へと参照する例を幾つか見てきました｡リストの例､ハッシュを使って検索を用意にする例などです｡これらの意味するところは､値同士の参照やインデックスを手動で管理しなければならないということです｡正直に言ってちょっとうんざりします｡とりわけ参照を手で管理し､更新し､削除しなければならないと考えると｡Redisにはこの問題を解決する魔法の杖はありません｡

既に見たようにこのタイプの手動インデックスには集合がよく使われます:

	sadd friends:leto ghanima paul chani jessica

この集合の各要素はユーザ情報を格納する文字列への参照になっています｡`chai`が名前を変えたり､アカウントを削除したりしたらどうなるでしょうか､逆向きの関係を保持しておくのが良いでしょう:

	sadd friends_of:chani leto paul

メンテナンスにかかる手間は別として､あなたが私と似たような人であれば､この余計なインデックスに費やすCPUリソースとメモリに身が縮む思いがするでしょう｡次の節では最初の種で簡単に触れたこういった余分な問い合わせのコストを減らす方法について検討します｡

しかしよく考えれば､RDBにも同様のオーバーヘッドがあるのです｡インデックスはメモリを消費し､総っしたり検索したり対応するデータを見つけ出したりするのにつかわれます｡こういったオーバーヘッドは上手く抽象化されています｡また同時に処理を効率的にするために非常に最適化されています｡

繰り返しますが､Redisにおいて参照を手で管理しなければならないのは不幸なことです｡しかし先ほど述べたようなパフォーマンスやメモリに関する不安は検証済みで､問題ないことにすぐ気がつくと思います｡

### 往復とパイプライン化

サーバへ頻繁に問い合わせをするのはRedisでは普通のことだと既に述べました｡頻繁におこうなうことなので､どのような機能を利用できるか詳しく見ておくことにしましょう｡

まず､ほとんどのコマンドは1つか2つの引数を取り､関連コマンドでは複数の引数を取るものもあります｡さきほど見た`mget`は複数のキーを引数に取り､複数の値を返します:

	keys = redis.lrange('newusers', 0, 10)
	redis.mget(*keys.map {|u| "users:#{u}"})

`sadd`コマンドは1つ以上の要素を集合に追加します:

	sadd friends:vladimir piter
	sadd friends:paul jessica leto "leto II" chani

Redisはパイプライン化をサポートしています｡普通はクライアントがRedisにリクエストを送った後､レスポンスが返ってきてから次のリクエストを送ります｡パイプライン化を使うとレスポンスを待つこと無く複数のリクエストを送ることができます｡これによってネットワークオーバーヘッドを減らし､多大なパフォーマンスゲインを得られます｡

Redisはコマンドをキューに保存するので､それは意味がありません｡したがってコマンドをバッチかするのはいい考えです｡(訳者注:意味不明､原文を以下に残す)It's worth noting that Redis will use memory to queue up the commands, so it's a good idea to batch them.
どれだけのコマンドをバッチにできるかは使うコマンドに依ります｡とりわけ引数のサイズに依ります｡しかし引数が50個までなら､1000とか10000とかのコマンドをバッチにできるでしょう｡

パイプラインでコマンドを使う方法はライブラリによって異なります｡Rubyでは以下のようにして`pipelined`メソッドにブロックを渡します:

	redis.pipelined do
	  9001.times do
		redis.incr('powerlevel')
	  end
	end

ご推察の通り､パイプライン化はバッチインポートを劇的に高速化します！

### トランザクション

Redisの全てのコマンドはアトミックです｡複数の処理をおこうものも含めて全てそうです｡加えてRedisは複数のコマンドを使うのにトランザクションをサポートしています｡

ご存じないかもしれませんがRedisはシングルスレッドで動きます｡それゆえに全てのコマンドがアトミックであることが保証されます｡一度に実行されるコマンドは常に1つだけです｡スケールアウトについては後ほど触れます｡いくつかのコマンドが複数の操作を行うと考えると､これはとても便利なことです:

`incr` は `set`の後に`get`を行うのと同じです

`getset` は新しい値を設定し､古い値を返します

`setnx` はまずキーが存在するかどうか確認し､キーが存在しない場合のみ値を設定します

これらのコマンドは便利ですが､複数のコマンドをひとまとめにしてアトミックに実行するのは必ず必要になります｡まずはじめに`multi`コマンドを実行し､続いて複数の操作をトランザクションとして実行し､最後に`exec`コマンドを実行して実際の処理を行うか､`discard`コマンドで操作を破棄します｡Redisのトランザクションで保証されるのはどんなことでしょうか？

* コマンドは順番通りに実行されます

* コマンドはアトミックな操作として実行されます(コマンドの実行の最中に他のコマンドが割り込んでくることはありません)

* トランザクション中のコマンドは､全てが実行されるか､全てが実行されないかのどちらかです

コマンドラインでこれらを確認できます､またそうすべきです｡また､パイプライン化とトランザクションを組み合わせて悪い理由は何もありません｡

	multi
	hincrby groups:1percent balance -9000000000
	hincrby groups:99percent balance 9000000000
	exec

最後に､Redisはキーを監視し､キーが変更された場合に条件に応じてトランザクション操作を行うことができます｡これはトランザクションの中で値を取得して､その値に基づいて処理を行う必要がある場合に使われます｡先ほどのコード例では独自の`incr`コマンドを実装することはできませんでした｡なぜなら`exec`が呼ばれたタイミングで全てのコマンドが一緒に実行されるからです｡つまり以下のようなことはできないわけです:

	redis.multi()
	current = redis.get('powerlevel')
	redis.set('powerlevel', current + 1)
	redis.exec()

Redisのトランザクションではこれは上手く行きません｡しかし`powerlevel`に`watch`を追加すれば､次のようにすることができます:

	redis.watch('powerlevel')
	current = redis.get('powerlevel')
	redis.multi()
	redis.set('powerlevel', current + 1)
	redis.exec()

もし他のクライアントが`watch`コマンドが実行された後に`powerlevel`を変更したとしたら､トランザクションは失敗します｡そうでなければ値の変更が実行されます｡このコードが成功するまでループの中で実行することができます｡

### キーに関するアンチ・パターン

次の章では特定のデータ構造と関係のないコマンドについて説明します｡いくつかは管理用であったりデバッグ用であったりします｡しかしとりわけ注目を要すると思うのは`keys`コマンドです｡このコマンドは引数にパターンを取りそのパターンにマッチするKeyを全て返します｡このコマンドは様々な用途に便利に使えそうです｡しかし実運用コードでは使うべきではありません｡なぜ？それは一致するKeyを探すために全てのキーを走査するからです｡簡単に言えば遅いということです｡

実際`keys`コマンドをどう使おうとするでしょうか？たとえばバグトラッキングサービスを作っているとしましょう｡各アカウントは`id`を持っているので､各バグ情報を文字列として`bug:account_id:bug_id`のようなキーに保存することにしたとします｡あるアカウントバグ情報すべてを探す荷は次のようにしたい誘惑に駆られるでしょう(私がそうであったように！):

	keys bug:1233:*

ハッシュを使うほうが良い解決策です｡セカンダリインデックスとしてハッシュを使ったように､データの構成にもハッシュを使えます:

	hset bugs:1233 1 "{id:1, account: 1233, subject: '...'}"
	hset bugs:1233 2 "{id:2, account: 1233, subject: '...'}"

あるアカウントのバグIDを全て得るには単に `hkeys bugs:1233` とします｡1つのバグを削除するには `hdel bugs:1233 2` とします｡アカウントを削除するには `del bugs:1233` とします｡

### この章のまとめ

この章と前の章を併せて､Redisを実際にどう活用するか多少なりとも理解してもらえたことと思います｡実際にはもっとたくさんのパターンがありますが､基本的データ構造を理解する鍵は､どのようにそれらを使って最初に思いついた以上のことができるかを知ることです｡
\clearpage

## 第四章 - データ構造を越えて

5つのデータ構造がRedisの基本である一方､データ構造に関係ないコマンドもあります｡これまでに見てきた `info` `select` `flushdb` `multi` `exec` `discard` `watch` `keys` などがそうです｡この章ではその他の重要なコマンドを紹介します｡

### キーの有効期限

Redisではキーに有効期限を設定することができます｡Unixタイムスタンプの形式で指定するか､秒数を指定できます｡これはキーに基づいたコマンドで､キーの表すデータ構造には関係ありません｡

	expire pages:about 30
	expireat pages:about 1356933600

最初のコマンドはキーとその値を30秒後に削除します｡二番目は2012年12月31日の12時に削除します｡

この機能はRedisをキャッシュの格納先として使うのに理想的です｡期限切れまでどれだけかを知るには `ttl` コマンドを使います｡有効期限を無くしたい場合は `persist` コマンドを使います:

	ttl pages:about
	persist pages:about

最後に､特別な文字レス操作コマンドがあります｡ `setex` は1つのコマンドで､文字列をセットすると同時に有効期限を設定することができます:

	setex pages:about 30 '<h1>about us</h1>....'

### パブリッシュとサブスクリプション

Redisのリストは `blpop` と `brpop` コマンドを持ち､これらのコマンドは最初か最後の要素を返すして削除するか､アクセスできるまでブロックするかします｡この2つのコマンドは簡単なキューを作るのに使えます｡

さらにRedisではメッセージの発行(パブリッシュ)と､チャネルへの登録(サブスクリプション)をファーストクラスサポートしています｡二つ目の `redis-cli` ウィンドウを開いて自分で試してみることができます｡一つ目のウィンドウでチャネルに登録し､そのチャネルを `warnings` と呼ぶことにします｡:

	subscribe warnings

登録の情報が返ってきます｡次に別のウィンドウで `warnings` チャネルにメッセージを発行します:

	publish warnings "it's over 9000!"

最初のウィンドウで `warnings` チャネルに発行したメッセージを受け取っているはずです｡

`subscribe channel1 channel2` として複数のチャネルに登録することができます｡あるいはパターンを使って (`psubscribe warnings:*`) としすることもできます｡ `unsubscribe` と `punsubscribe` コマンドを使うと登録を解除できます｡

最後に､`publish`コマンドが1を返すことに注意してください｡これはメッセージを受け取ったクライアントの数を表しています｡


### Monitor と Slow Log

`monitor`コマンドはRedisの状態を表示します｡アプリケーションがRedisとどんなやり取りをしているのかを見ることができるので､デバッグに便利です｡redis-cliを2つのウィンドウで立ち上げて､一方で`monitor`コマンドを打ち込み､他方で`get`や`set`などのコマンドを実行してみてください｡それらのコマンドがパラメータ付きで最初のウィンドウに表示されるはずです｡

実運用環境でmonitorコマンドを使うのは慎重にすべきです｡monitorはデバッグと開発用です｡それ以外には特に言うべきことはありません｡とても便利なツールです｡

`monitor`とあわせて､Redisにはプロファイリングに使える`slowlog`コマンドがあります｡このコマンドは指定された**マイクロ**秒以上かかっている全てのコマンドを記録します｡次の章ではRedisの設定を簡単に説明しますが､ひとまず全てのコマンドを記録するのに次のように設定できます:

	config set slowlog-log-slower-than 0

次に幾つかコマンドを実行しましょう｡そして全てのログか直近のログを取得します:

	slowlog get
	slowlog get 10

記録されたログの数を数えるには`slowlog len`とします｡

実行した各コマンドに対して4つのパラメータが表示されます:

* 自動採番されたID

* コマンド実行時のUnixタイムスタンプ

* コマンド実行にかかった時間､マイクロ秒単位

* コマンドとそのパラメータ

slow logはメモリ上に保存されます｡そのため低閾値であっても実運用環境での実行も問題ありません｡デフォルトでは最新の1024個のコマンドをログに保持します｡

### ソート

Redisのもっとも強力なコマンドのうちの1つは`sort`です｡リストや集合､ソート済み集合にある値をソートすることができます｡ソート済み集合の場合はメンバーではなくスコアでソートされます｡ソートの一番単純な形は次のようなものです:

	rpush users:leto:guesses 5 9 10 2 4 10 19 2
	sort users:leto:guesses

値が小さなものから大きなものへと並べ替えられて返されます｡さらに進んだ例は次のようなものです:

	sadd friends:ghanima leto paul chani jessica alia duncan
	sort friends:ghanima limit 0 3 desc alpha

この例では並べ替えしたデータを`limit`でページ分けし､`desc`で並び替えを降順にし､`alpha`でアルファベット順に並べ変えしています｡

`sort`の真の力は参照オブジェクトに基づいて並べ替えができることです｡先ほどリストや集合､ソート済み集合が他のRedisオブジェクトを参照するのに使われる例を紹介しました｡`sort`コマンドはそれらを逆参照して得た値で並べ替えをすることができます｡例としてユーザが問題を監視できるバグトラッキングシステムがあったとしましょう｡監視する問題を設定するには集合を使うでしょう:

	sadd watch:leto 12339 1382 338 9338

これらのIDに基づいてソートするのも完全に理にかなっているのですが､問題の深刻度によってもソートしたいとします｡そのためにはRedisにソート用のパターンを指定してやります｡まずは結果をわかり易くするためにデータを幾つか追加しましょう:

	set severity:12339 3
	set severity:1382 2
	set severity:338 5
	set severity:9338 4

バグを深刻度の高いものから低いものへソートするには､次のようにします:

	sort watch:leto by severity:* desc

Redisはby以降で指定された`*`の部分をリスト/集合/ソート済み集合の値で置き換えます｡置き換え後に得られたキーが実際の並べかえに使う値を得るのに参照されます｡

Redisには何百万ものキーを保存できるとはいえ､先程の例はキーの管理という面でちょっと面倒かと思います｡ありがたいことに `sort` コマンドはハッシュを扱うことができます｡キーをたくさん作る代わりにハッシュを利用できます:

	hset bug:12339 severity 3
	hset bug:12339 priority 1
	hset bug:12339 details "{id: 12339, ....}"

	hset bug:1382 severity 2
	hset bug:1382 priority 2
	hset bug:1382 details "{id: 1382, ....}"

	hset bug:338 severity 5
	hset bug:338 priority 3
	hset bug:338 details "{id: 338, ....}"

	hset bug:9338 severity 4
	hset bug:9338 priority 2
	hset bug:9338 details "{id: 9338, ....}"

より整理されただけでなく､`severity`や`priority`でのソートもでき､さらにどのフィールドを取得するか`sort`コマンドに指示することもできます:

	sort watch:leto by bug:*->priority get bug:*->details

先ほどと同じように`*`が置き換えられますが､同時に`->`がハッシュの参照するフィールドを指定します｡また`get`パラメータをつかうことで､バグの詳細を取得しています｡

巨大な集合に対しては`sort`は遅くなることがあります｡`sort`結果は保存することができます:

	sort watch:leto by bug:*->priority get bug:*->details store watch_by_priority:leto

`store`を期限切れ(expiration)コマンドと一緒に使うのはよい組み合わせでしょう｡

### この章のまとめ

この章ではデータ構造に関係のないコマンドに焦点を当てました｡他の全てと同じくこれらのコマンドを使う場面は様々です｡expiration,publication/subscription,sortを使わないアプリケーションや機能を作ることも稀ではありません｡しかしこういったコマンドがあるということを知っておくのいいことです｡また､ここではいくつかのコマンドに触れたに過ぎません｡この本の内容を消化したら[完全なリスト](http://redis.io/commands)に目を通してみるとよいでしょう｡

\clearpage

## 第五章 - 管理作業

最後の章はRedisを運用するための管理作業についてです｡この僅かな解説では到底Redis管理のための完全な手引きにはなりえませんが､Redisを使い始めるにあたって多くの人がぶつかるであろう基本的な疑問に可能な限り答えたいと思います｡

### 設定

Redisを初めて起動したとき､`redis.conf`ファイルがないという警告が表示さました｡このファイルはRedisの様々な設定をするのに使います｡詳しいコメント付きの `redis.conf` ファイルがRedisの各リリースに含まれています｡サンプルにはデフォルトの設定が書いてあるので､設定の意味とデフォルト値を知るのに便利です｡このファイルは <https://github.com/antirez/redis/raw/2.4.6/redis.conf> にあります｡

**この設定ファイルはRedis 2.4.6のものです｡URLの"2.4.6"をお使いのバージョンに置き換えてください｡バージョンは`info`コマンドで確認できます｡**

ファイル内に詳細なコメントがあるので､ここでは設定については触れません｡

`redis.conf`ファイルで設定をするのに加えて､`config set`コマンドで個々の値を設定できます｡実は先程使った`slowlog-log-slower-than`を0にしたのはこれでした｡

`config get`というコマンドもあって､設定値を表示します｡このコマンドはパターンマッチをサポートしており､例えばログ関連の設定を全部表示したいなら:

	config get *log*

とすることができます｡

### 認証

Redisがパスワードを要求するよう設定できます｡`requirepass`にパスワードを設定することでこの機能が有効になります｡クライアントは`auth password`コマンドを発行して認証を行う必要があります｡

一旦クライアントが認証を済ませると､全てのキーをデータベースから削除する`flashall`コマンドもふくんだ､あらゆるコマンドが実行可能になります｡次に示すようにコマンド名を変更して難読化することでセキュリティを高めることができます:

	rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
	rename-command FLUSHALL 1041285018a942a4922cbf76623b741e

新しい名前を空文字列にするとコマンドは使えなくなります｡

### サイズの限界

Redisを使い始めると､「いくつのキーを保存できるんだろう？」と考えることでしょう｡あるいはハッシュにはどれだけのフィールドを格納できるのか､リストや集合はどれだけの要素を持てるのか､といったことも気になるかもしれません｡現実的にはこれらの限界は何億という数値です｡


### レプリケーション

Redisはレプリケーションをサポートしています｡マスターのRedisインスタンスにデータを書き込むと､一つかそれ以上のスレーブインスタンがマスターの更新に追従するという機能です｡スレーブの設定は設定ファイルの`slaveof`値か､`slaveof`コマンドで行えます｡この設定なしで実行されるインスタンスはマスターになりえます｡

レプリケーションはデータを複数のサーバにコピーすることでデータを保護するのに役立ちます｡データの読み出しをスレーブに任せることでパフォーマンスの改善にも使えます｡これはわずかに古くなったデータを返す可能性がありますが､ほとんどのアプリケーションにとっては許容できる代償でしょう｡

残念なことに､Redisのレプリケーションは自動フェイルオーバーに対応していません｡マスターが落ちたら､スレーブを手動でマスターに昇格させなければなりません｡Redisで高可用性を実現しようとするなら､広く使われている生存監視を使った高可用性ツールやスレーブを自動で切り替えるスクリプトを利用する手間が必要です｡

### バックアップ

Redisのバックアップはスナップショットファイルをどこでも好きなところにコピーするだけです｡デフォルトではRedisはスナップショットを`dump.rdb`という名前のファイルに保存します｡いつの時点でもこのファイルを`scp` `ftp` `cp`することできます｡

スナップショットとアペンドオンリーファイル(aof)の両方を無効にして､スレーブにこれらの役割を任せてしまうのは珍しいことではありません｡これによって全体のシステムのパフォーマンスを損なうこと無く､マスターの負荷が減り､スレーブで高頻度で保存を行えます｡

### スケールアウトとRedisクラスタ

レプリケーションはサイトの負荷増大に伴って使える最初の手段です｡コマンドの中には実行に高いコストのかかるものがあり（例えば`sort`など）､高いったコマンドの実行をスレーブに任せることで全体の応答性を高く保つことができます｡

レプリケーションのさらに先､Redisで本当のスケールアウトをするには､キーを複数のインスタンス(これらは一つのサーバで実行され得るでしょう｡思い出してください､Redisはシングルスレッドなのです)に分散配置するということになります｡現在のところ､この機能は自分で何とかする必要があります(多くのRedisドライバは一貫性を保ったハッシュアルゴリズムを提供していますが)｡データの水平分散はこの本で扱う内容をこえています｡またしばらくの間はそんな心配も必要ないでしょう｡しかしこの話題はどんな解決法を採るにしろ､気がついていなければならないことです｡

ここで良いお知らせです｡Redis Clusterが現在開発中で､この機能はデータの水平分散を可能にするだけでなく､ロードバランス機能や自動フェイルオーバー機能も含んでいます｡

高可用性とスケールアウトは手間暇を惜しまなければ現状でも十分に実現可能です｡将来的にはRedis Clusterがもっと話を簡単にしてくれるでしょう｡

### この章のまとめ

既にRedisを利用しているサイトやプロジェクトの数を考えると､Redisを実戦投入できるということには疑いの余地はありません｡しかしセキュリティや可用性のツールについてはまだ未成熟です｡期待の高まるRedis Clusterが管理業務の課題を解決してくれるはずです｡

\clearpage

## 結論

様々な点において､Redisはデータを扱う方法の単純化を示しています｡他のやり方にあるような複雑さや抽象化は､そこにはありません｡多くの場合､これがRedisを間違った選択にします｡その他の場合は､Redisはあつらえたようにぴったりだと感じられるでしょう｡

結局は私がこの本の最初に述べたことに戻ってくるのです｡Redisは簡単に学べます｡新技術は数あれど､学ぶに値するかどうかを知ることすら難しいことがあります｡Redisの単純さによってもたらされる真の利点を考えると､あなたとあなたのチームにとって､Redisを学ぶのは良い投資だと私は心から信じています｡
